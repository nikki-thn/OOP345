#ifndef W8_DATATABLE_H
#define W8_DATATABLE_H

#include <iostream>
#include <fstream>
#include <algorithm>
#include <numeric>
#include <vector>
#include <exception>
#include <math.h>


namespace w8 {

	template<typename T>
	class DataTable {
		int m_width;
		int m_decimal;
		int m_numRecs;
		std::vector<T> m_dataX;
		std::vector<T> m_dataY;
	public:

		DataTable() : m_width(0), m_decimal(0), m_numRecs(0) {}

		DataTable(std::ifstream& ifs, const int width, const int decimal) {

			if (!ifs.fail() && ifs.is_open()) {
				T x;
				T y;
				m_numRecs = 0;
				while (!ifs.eof()) {
					ifs >> x >> y;
					m_dataX.push_back(x);
					m_dataY.push_back(y);
					m_numRecs++;
				}
				m_width = width;
				m_decimal = decimal;
			}

			else { *this = DataTable(); }
		}

		//- returns the mean value of the dependent coordinate
		T mean() const {
			T mean;
			mean = std::accumulate(begin(m_dataY), end(m_dataY), 0.0f) / m_numRecs;
			return mean;
		}

		//- returns the standard deviation of the dependent coordinates
		T sigma() const {
			T sigma;

			T diff_total = 0;
			for (auto i : m_dataY) {
				diff_total += pow((i - mean()), 2);
			}

			sigma = sqrt((diff_total) / (m_numRecs - 1));

			return sigma;
		}

		// - returns the median value of the dependent coordinate
		T median() const {
			T median;
			std::vector <T> m_copyDataY = m_dataY;

			sort(begin(m_copyDataY), end(m_copyDataY));
			int index = -1;
			if (m_numRecs % 2 == 0) {
				index = m_numRecs / 2;
				median = m_copyDataY[index];
			}
			else {
				index = m_numRecs / 2;
				median = m_copyDataY[index + 1];
			}
			return median;
		}

		// - returns the slope and intercept for the data set
		void regression(T& slope, T& y_intercept) const {
			T sumOfXY = 0, sumOfX = 0, sumOfY = 0, sumOfX2 = 0;

			sumOfX = std::accumulate(begin(m_dataX), end(m_dataX), sumOfX);
			sumOfY = std::accumulate(begin(m_dataY), end(m_dataY), sumOfY);
			sumOfX2 = std::accumulate(begin(m_dataX), end(m_dataX), sumOfX2, [](T total, T value) {return total += value*value; });

			std::vector <T> dataXY(m_numRecs);
			std::transform(begin(m_dataX), end(m_dataX), begin(m_dataY), begin(dataXY),
				std::multiplies<float>());

			sumOfXY = std::accumulate(begin(dataXY), end(dataXY), sumOfXY);

			slope = (m_numRecs * sumOfXY - sumOfX* sumOfY) / (m_numRecs * sumOfX2 - pow(sumOfX, 2));
			y_intercept = (sumOfY - slope*sumOfX) / m_numRecs;
		}

		// - displays the data pairs as shown below
		void display(std::ostream& os) const {

			//*** CRASH when display function has a body or when os is used
		/*	for (int i = 0; i < m_numRecs; i++) {
				std::cout << m_dataX[i] << "     " << m_dataY[i] << std::endl;
			}*/
		}

	};

	template<typename DataTable>
	//- inserts the data generated by display() into the output stream
	std::ostream& operator<<(std::ostream& os, const DataTable& dt) {
		dt.display(os);
		return os;
	}

}

#endif
